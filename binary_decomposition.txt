Binary Decomposition: Turn n into list of smallest powers of 2 that sums to n.

Time: O(logn)
'''
  pows = []

  i = 1 # tracks power of 2
  while n>0:
    # LSB = 1
    if n%2==1:
      pows.append(i)

    # right-shift
    n //= 2
    i *= 2
'''

1. Binary = Sum of Powers of 2
- Every positive int can be uniquely writtern as sum of powers of 2
- For example: n = 13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0 -> binary: 1101

2. What does n % 2 == 1 check?
When you do:
'''
  if n % 2 == 1:
    pows.append(i)
'''

- You are checking if the least significant (last) bit, or LSB is 1.
- n % 2 == 1 -> current last bit is 1, that means this power of 2 is used in 1
  => In other words, the current number is odd. Only odd number has the last bit = 1

3. Why n //= 2?
- This moves the binary window one bit to the right.
- For example: 13: 1101, next number is 13//2 = 6: 110

4. Lastly, what is i?
- i basically tracks the currently power of 2 we are at.
- starts at 1 and double every iteration.

